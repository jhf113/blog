# 进程间通信
每个进程的用户地址空间都是独立的，一般来说是不能互相访问的，但是内核空间是每个进程共享的，所以进程之间要通信就必须通过内核。进程间通信主要包括管道、消息队列、共享内存、信号量、信号及socket。
进程之间的通信方式主要有六种，包括管道，信号量，消息队列，信号，共享内存，套接字。
**管道：**管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的
**匿名管道pipe**和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。

**信号量：**信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。

**信号：**信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的

**共享内存：**共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。
**消息队列：**消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。

**消息队列与管道通信相比**，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。

**套接字：**套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

## 管道
管道（' | '）的功能时将前一个命令的输出作为后一个命令的输入，管道是半双工通信，传输数据是单向的。管道分为匿名管道和命名管道，匿名管道是特殊的文件，只存在于内存，不存在于文件系统中，它用完了就销毁。而命名管道使用前要通过mkfifo命令来创建，因为linux一切皆文件的理念，所以管道也是以文件的方式存在，（类型是p也就是pipe的意思）
**管道原理**
我们用pipe系统调用创建一个匿名管道后，会返回两个描述符，一个是读端描述符fd[0]，另一个是管道写端描述符fd[1]，管道就是内核里面的一串缓存。从管道的一端写入的数据，实际上是缓冲在内核中，另一端读取，也就是从内核中读取这段数据。管道传输的数据是无格式的，并且它的大小受限。要让它实现进程间通信的话，我们得使用fork来创建一个子进程，创建的子进程会复制父进程的文件描述符，这样两个进程就各有两个fd[0]、fd[1]了，我们就可以通过各自fd读写同一个管道文件实现跨进程通信。
为了避免父子进程同时读或同时写：
* 父进程关闭读取的fd[0]，只保留写入的fd[1]；
* 子进程关闭写入的fd[1]，只保留读取的fd[0]；

**管道优缺点**
缺点就是管道这种通信方式效率低，不适合进程间频繁地交换数据，优点就是简单，同时我们很容易可以得知管道里的数据是否已经被另一个进程读取了。
**匿名管道**
它的通信范围是存在父子关系的进程，因为管道没有实体，也就是没有管道文件，只能通过fork来赋值父进程fd文件描述符，来达到通信的目的。
**命名管道**
它可以在不相关的进程间也能相互通信，因为命名管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信了。

## 消息队列
消息队列可以解决管道通信方式效率低的情况。比如，A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去取数据就可以了。同理，B给A发消息也一样。
**消息队列原理**
消息队列时保存在内核中的消息链表。在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，它不像管道是无格式的字节流数据。如果进程从消息列表中读取了消息体，内核就会把这个消息体删除。
**消息队列生命周期**
消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯提到的匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁。
**消息队列优缺点**
优点，通过消息队列，两个进程间的通信就像发消息一样，你一句，我一句，可以频繁的沟通。不足就是通信可能会不及时，通信的数据大小也有限制。
	• 消息队列不适合⽐较⼤数据的传输，因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ，它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度。
	• 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销，因为进程写入数据到内核中的消息队列时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程。

## 共享内存
共享内存相较于消息队列而言，它解决了用户态与内核态之间消息拷贝的过程。我们现在用的操作系统，对于内存管理，才用的是虚拟内存技术，也就是说每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存可以映射到不同的物理内存中。所以，即使进程A和进程B的虚拟内存是一样的，但其实访问的是不同的物理内存地址，对于数据的增删改是互不影响的。
**共享内存的原理**
共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中，这样这个进程写入的东西，另外一个进程马上就能看到了，不需要来回拷贝什么的，大大提高了进程间通信的速度。
**共享内存的优缺点**
优点就是提高了进程间通信的速度，缺点就是没有提供同步与互斥的机制，如果多个进程同时修改了同一个共享内存，很可能就冲突了。比如两个进程同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

## 信号量
信号量提供了保护机制，它使得共享的资源，在任一时刻只能被一个进程访问，防止多进程竞争共享资源，而造成的数据错乱。
**信号量的原理**
信号量其实是一个整型的计数器，主要就用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示的是资源的数量，我们有两种原子操作进行控制信号量：P操作 和 V操作。P操作是用在进入共享资源之前，V操作是用在离开共享资源之后，两个操作必须成对出现。
信号量操作
* P操作：会把信号量减去1，相减后如果信号量 <0，则表明资源已经被占用，进程需要阻塞等待；相减后如果信号量>=0，则表明还有资源可以使用，进程可以正常继续执行。
* V操作：会把信号量加上1，相加后如果信号量 <=0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 >0，则表明当前没有阻塞中的进程；

最简单的例子就是生产者消费者模型。
**初始化信号量**
**初始化为1：**代表互斥信号量。举个例子，A、B进程都要访问共享内存且信号量都初始化为1，进程A在访问共享内存前，先执⾏了P操作，因为信号量的初始值为1，所以进程A执⾏P操作后信号量变为0，表示共享资源可⽤，所以它就可以访问共享内存了。 如果这个时候，B也想访问共享内存，它执行了P操作，结果信号量变成了-1，就代表这个资源已经被占用了，所以它就被阻塞了。直到进程A访问完共享内存，才会去执行V操作，让信号量恢复为0，接着就会唤醒进程B，B就可以去访问共享内存了，最后访问完，执行V操作，把信号量恢复成初始值1。

**初始化为0：**代表同步信号量。这个也举个例子，还是A、B进程，A进程负责生产数据，B进程负责读取数据，A必须生产了数据，B才能读取到数据，我们把初始值都设为0，如果进程B比进程A先执行了，那么执行到P操作时，因为信号量初始值为0，所以信号量会变成-1，表示A还没生产数据呢，于是B就阻塞等待了。然后当A生产完数据后，执行了V操作，就会使得信号量变为0，于是就会唤醒阻塞在P操作的B。最后B被唤醒了，也就代表A已经生产了数据，于是B就可以正常读取数据了。

## 信号
信号是针对于处于异常情况下的工作模式，比如我们要通过键盘和一些命令，给进程发送信号。Linux下
* Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程；
* Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束；
* kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，⽤来⽴即结束该进程；

**信号的原理**
信号是进程间通信机制中唯⼀的异步通信机制，因为它可以在任何时候发送信号给某⼀进程，⼀旦有信号产⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。
1. 执⾏默认操作。Linux对每种信号都规定了默认操作，例如，上⾯列表中的 SIGTERM 信号，就是终⽌进程的意思。
2.  捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。
3.  忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。但是有两个信号是应⽤进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们⽤于在任何时候中断或结束某⼀进程。
