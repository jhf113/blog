# TCP拥塞控制
在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。
最坏结果：**系统崩溃**。

**拥塞产生的原因**
网络拥塞往往是由许多因素引起的。例如：
点缓存的容量太小；
链路的容量不足；
处理机处理的速率太慢；
拥塞本身会进一步加剧拥塞；
出现拥塞的原因：

**增加资源能解决拥塞吗？**
不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。
网络拥塞往往是由许多因素引起的。例如：
1.增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；
2.提高处理机处理的速率会会将瓶颈转移到其他地方；

防止过多的数据注入到网络中，这样可以使网络中点的路由器或链路不至过载，拥塞控制自然也是控制发送者的流量，拥塞控制用四种算法，**慢启动，拥塞避免，快速重传，快速恢复**。

发送发位置一个拥塞窗口cwnd的状态变化量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的改变，发送方让自己的发送窗口等于拥塞窗口和接收窗口的最小值
1. ***慢启动***：慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由大到小逐渐增加拥塞窗口的大小，而这个大小是指数增长的
为防止拥塞窗口cwnd增长过大引起网络堵塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过阈值的时候，停止使用慢启动算法而改用拥塞避免算法.
2.  ***拥塞避免***：拥塞避免算法的思路就是让拥塞窗口cwnd缓慢的增大，即经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍.
在发生超时重传的时候，将阈值设置成原来拥塞窗口的/2，将cwnd=1。
无论是慢启动算法还是拥塞避免算法，只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（>=2），cwnd(拥塞窗口)设置为1，然后在使用慢启动算法，这样做的目的能迅速的减少主机向网络中传输数据，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。拥塞窗口是按照线性的规律增长，比慢启动算法拥塞窗口增长块的多。

**实例：**
* TCP连接进行初始化的时候，cwnd=1,ssthresh=16。
* 在慢启动算法开始时，cwnd的初始值是1，每次发送方收到一个ACK拥塞窗口就增加1，当ssthresh =cwnd时，就启动拥塞控制算法，拥塞窗口按照规律增长，
* 当cwnd=24时，网络出现超时，发送方收不到确认ACK，此时设置ssthresh=12,(二分之一cwnd),设置cwnd=1,然后开始慢启动算法，当cwnd=ssthresh=12,慢启动算法变为拥塞控制算法，cwnd按照线性的速度进行增长。
3. ***快速重传***：当发送端连续接收到三个ack时，表示该数据段已经丢失，需要重新发送，
4.***快速恢复***：当发送方一旦接受到3个重复确认，就知道现在只是丢失了个别报文段，于是不启动慢开始，而执行快速恢复，将ssthresh=cwnd=cwnd/2。开始执行拥塞避免，也有的快速重传是吧cwnd=ssthresh+3
***使用拥塞避免算法***
![Alt text](https://wx3.sinaimg.cn/mw2000/008sKdQply1h25zd66qyyj30n10akadx.jpg)

   开始时cwnd=1，可能是因为上一次阶段发生了堵塞（超时重传）现在执行慢启动，每经过一个传输轮次cwnd*2当cwnd=16 时（阈值=16),执行堵塞避免算法，每经过一个传输轮次cwnd+1，当传输轮次=12是cwnd=24，发现cwnd有一个断崖式下降，因为这个时候tcp判断网络发生拥塞（超时重传），阈值等于cwnd/2，cwnd=1，然后执行慢启动算法，当传输轮次=18，cwnd=12等于当前阈值，执行拥塞堵塞算法
![Alt text](https://wx4.sinaimg.cn/mw2000/008sKdQply1h25zd8485bj30o30crq75.jpg)
开始执行慢启动算法，阈值=16，当传输轮次等于4的时候cwnd=16，开始执行拥塞避免算法，当传输轮次=12 cwnd=24发生了快重传，阈值=cwnd/2，cwnd=阈值，然后执行拥塞避免算法，
