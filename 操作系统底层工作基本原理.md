# 操作系统底层工作的基本原理
## 一. 计算机的五大组成部分

**1. 控制器(Control)：**
是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设
的访问等。
**2. 运算器(Datapath)：**
运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。
**3. 存储器(Memory)：**
存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。
**4. 输入(Input system)：**
输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。
**5. 输出(Output system)：**
输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。
 ![Alt text](https://wx1.sinaimg.cn/mw2000/008sKdQply1h2ifd9lukij30oz0dstb5.jpg)


**输入设备和输出设备是如何工作的呢?**
在电路板里,尤其是在cpu包含了大量的电路, 电路是根据电流的高低压进行判断, 根据电流的开/关不同, 会影响电信号的强度, 这样就会导致两种以结果, 一种是关闭了,还是没关闭. 关闭了是0, 没关闭是1. 所以为什么cpu只认0和1, 也是因为这个原因.
**其实电路板, 我们都可以自制. 如何自制呢?**
其实就是在一块板子上, 镀了一层铜膜, 然后设计电路, 在一类特殊类型的纸上设计, 设计好了以后, 把纸贴到镀了铜的电路板上去. 纸上有我们设计好的电路, 然后把这个板子丢到化学反应池里, 然后没有贴特殊纸的地方将会发生化学反应,把没有贴到线路的铜膜擦掉

**上面的模型是一个理论的抽象简化模型，它的具体应用就是现代计算机当中的硬件结构设计：**
![Alt text](https://wx4.sinaimg.cn/mw2000/008sKdQply1h2ifdcw7cqj30xo0kojxx.jpg)
**现代计算机的构成主要有**

* CPU
* 主板
* 内存条
* 硬盘
* 电源

一台电脑中, 上面这五个就是核心设备了,有了这5个,一台计算机就可以工作了.显卡,键盘,鼠标,网卡,都可以没有
**cpu是非常重要的, 对于cpu我们需要重点了解两个方面的内容**
1. cpu是如何工作的.
2. cpu是如何和内存进行通讯的.
计算机主板上有很多的插槽,其中一部分是放cpu的,另一部分是放内存条的. 那么cpu和内存条怎么通信呢?
cpu和内存条都是插在主板上的,他们并不在一块. 那么他们想要通信, 就要通过信道, 信道, 我们又可以叫做内存总线, 系统总线, IO总线. 他们是通过总线进行通讯的

在上图硬件结构当中，配件很多，但最核心的只有两部分：CPU、内存。所以我们重点学习的也是这两部分。
## 二. CPU
**2.1 CPU内部结构**
cpu的内部构造很复杂, 主要有3个单元.
* 控制单元
* 运算单元
* 数据单元
![Alt text](https://wx4.sinaimg.cn/mw2000/008sKdQply1h2ifdgel0uj30me0egq80.jpg)
 最直接操作计算机的是什么语言? 是汇编语言

**2.1.1 控制单元**
控制单元, 说白了, 在执行命令的时候, 会有一些if判断, while循环等, 这些控制类的命令就放在控制单元里

控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。

**2.1.2运算单元**
这里简单理解是什么呢? 比如 1+2 2*3  5/2, 这些和运算有关系的都放在运算单元里. 专门负责算术的运算

运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。

**2.1.3 存储单元**
主要是对结果的临时存储. 这里包含寄存器, CPU的缓存.

存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。下表列出了CPU关键技术的发展历程以及代表系列，每一个关键技术的诞生都是环环相扣的，处理器这些技术发展历程都围绕着如何不让“CPU闲下来”这一个核心目标展开
![Alt text](https://wx4.sinaimg.cn/mw2000/008sKdQply1h2ifdj39eij30uo0judl0.jpg)

**2.2 CPU缓存结构**
cpu对于计算机, 就像我们人的大脑.
现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构，
常见的为三级缓存结构
	• L1 Cache，分为数据缓存和指令缓存，逻辑核独占
	• L2 Cache，物理核独占，逻辑核共享
	• L3 Cache，所有物理核共享

**2.2.1 cpu为什么需要缓存呢?**
根据摩尔定律, cpu的性能, 大概每过18个月, 性能就会翻一番. cpu从90年代到2020年, 经过了20多年的发展, 现在基本上进入了性能过剩的时代.
但是内存,经过了很多年的发展, 却没有什么摩尔定律, 我们知道内存从原来的DDR2 发展到 DDR3, 有发展到DDR4, 到现在的DDR5, 其实这个变化并没有那么大
所以就造成了失衡的问题. 内存的速度远远跟不上CPU的速度了, 而每一次计算CPU都要去内存里拿数据, 这样太耗费时间了. 所以, 为了解决这个问题, CPU增加了多级缓存. 增加多级缓存目的就是为了减少与内存的交互

**2.2.2来看一下我们使用的计算机**
![Alt text](https://wx3.sinaimg.cn/mw2000/008sKdQply1h2ifdmmlrzj316g0taap8.jpg)

 看看这个计算机的基本信息, 此计算机有一个CPU. 那么这一个和我们之前说的1核,2核是一回事么? 不是一回事
.根据计算能力, 一台电脑可以安装一个或多个CPU, CPU越多, 计算的速度相应的也会越快, 每个CPU可以有一核或者多核
问题:  现在有一个线程, 运行在4个cpu上, 和运行在有一个cpu, 但这个cpu有四个核, 哪一个更快呢?显然收前者处理更快. 相应的性价比却低很多.
如上图, 还有内核和虚拟处理器, 一个是4, 一个是8. 这里虚拟处理器的含义是: 原来4核四线程, 那么每个容器可以执行一个线程. 这里虚拟化是指原来一个cpu内核只能跑一个线程, 现在可以跑两个线程了.

**2.2.3 CPU的三级缓存**
还是看上图, CPU有三级缓存, L1缓存 256kb, L2缓存 1.0MB  L3缓存 8.0M  L1 < L2 < L3.
L1离CPU是最近的, 离得越近速度越快. M < L3 < L2 < L1 < 寄存器. 数据拷贝的过程是, 从内存拷贝到L3, 在拷贝到L2, 在拷贝到L1, 再拷贝到寄存器.
CPU操作的数据只会去寄存器里面存或者取. 寄存器是每一个cpu独有的. 这个寄存器只能被当前的cpu访问到, 不能被其他cpu访问
**2.2.4 三级缓存和cpu有什么关系呢?**
* L3是CPU内核共享的, 就是说被当前这个CPU的所有内核共享.
现在有两个CPU, CPU2能不能访问到CPU1的L3缓存呢?
答案是: 不能. 不能跨CPU访问别人的缓存
* L1和L2是每个CPU上各内核独享的.
* 一个内核只有一个L1和一个L2, 在图中我们看到L1有两个, 是因为L1有两个功能, 一个是用来存储指令, 另一个是用来存储数据的. L1只有一个, 只是根据功能将其分为两个部分.
* L1缓存分为两种, 一种用来存储指令, 另一种用来存储数据.
![Alt text](https://wx1.sinaimg.cn/mw2000/008sKdQply1h2ifdovzv0j30px0l5dkz.jpg)

 现在大多数计算机的架构都是如上图, 最底下是内存, 然后有一条总线连接cpu和内存条

存储器存储空间大小：内存>L3>L2>L1>寄存器；
存储器速度快慢排序：寄存器>L1>L2>L3>内存；
还有一点值得注意的是：缓存是由最小的存储区块-缓存行(cacheline)组成，缓存行大小通常为64byte。
**2.2.5 我们能看到L3缓存有6M, 那么这6M没有一个划分么? 就是一块空间么?**
不是的. 缓存也有一个最小的存储单元, 这个最小的存储单元叫做"缓存行" , 通常, 缓存行的大小是64byte, 市面上的cpu基本都是这么大. 那我有一个6M的缓存, 他有多少缓存行呢? 6 * 1024k * 1024b/64.
那么, 如果是一个long类型, 8位, 一个缓存行可以存几个long型呢? 64/8 = 8个
int呢?一个缓存行可以存几个int呢? int是4位, 64/4 = 16个
缓存行是什么意思呢？它是CPU缓存中, 最小的空间存储单位, 叫cacheline.
比如你的L1缓存大小是512kb,而cacheline = 64byte,那么就是L1里有512 * 1024/64个cacheline


问题: 如果有一个变量是256b, 而我们的缓存行是64b, 存不下咱么办?

这时候我们可以分配4个缓存行来存储. 这就是跨缓存行存储.
![Alt text](https://wx3.sinaimg.cn/mw2000/008sKdQply1h2ifdvat42j30uk0i479n.jpg)


**2.2.6 寄存器**
每个cpu内核都有一个自己的寄存器, 这个寄存器是内核独享的, 如下图, 每个内核都有一个寄存器.
**2.2.7 缓存行的使用**
![Alt text](https://wx2.sinaimg.cn/mw2000/008sKdQply1h2ifdysugxj30x40mewmr.jpg)
现在cpu要开始计算了, 他需要获取一个x参数, 首先, 他会去L1 一级缓存获取, 一级缓存没有, 再去二级缓存拿, 二级缓存没有再去三级缓存拿, 三级缓存也没有再去内存里找.
在内存找到了x=0, 然后将其拷贝到L3缓存中, 在拷贝到L2缓存, 在拷贝到L1缓存中. 然后在读到寄存器里面去,供cpu使用

如果变量都拷贝到缓存里, 很快就会满了, 最先满的就是L1(他最小嘛) 然后, 他就有一个高淘汰的风险. 因为要腾出地方来给其他变量使用.
加入这个时候,L1中x=0变量被淘汰了,  当cpu需要计算的时候怎么办呢? 没关系, 因为寄存器里面已经有了x=0. 假如寄存器也淘汰了, 怎么办呢? 他去L1也取不到, 那就去L2取, 如果L2也淘汰了,就去L3,总之, 他可以现在3级缓存中取数据, 不用立刻就去内存中取.

**2.2.8 CPU读取存储器数据的过程**
1、CPU要取寄存器X的值，只需要一步：直接读取。
2、CPU要取L1 cache的某个值，需要1-3步（或者更多）：把cache行锁住，把某个数据拿来，解锁，如果没锁住就慢了。
3、CPU要取L2 cache的某个值，先要到L1 cache里取，L1当中不存在，在L2里，L2开始加锁，加锁以后，把L2里的数据复制到L1，再执行读L1的过程，上面的3步，再解锁。
4、CPU取L3 cache的也是一样，只不过先由L3复制到L2，从L2复制到L1，从L1到CPU。
5、CPU取内存则最复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存到L3（如果没有就到L2），再从L3/2到L1，再从L1到CPU，之后解除总线锁定。
**2.2.9 CPU为何要有高速缓存**
CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。
在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。
	• 时间局部性（Temporal Locality）
如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。比如循环、递归、方法的反复调用等。
	• 空间局部性（Spatial Locality）：
如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。
**2.2.9.1 什么是空间局部性原则呢?**
我们都知道CPU和内存的交互是很慢的, 所以增加了3级缓存, 那好不容易交互一次, 费了很大劲就取了一个x=0, 是不是很浪费, 所以, CPU在和内存交互的时候, 不是只去x=0, 而是把x变量周边的变量都会取回来. 比如y=1, z=2, n=3. CPU会一次性将这些数据都copy一份到3级缓存里去.
为什么这样做呢?
如果一个变量被引用, 那么将来他附近的变量也会被引用, 因此, cpu会一次性将这些变量全部加载到cpu的缓存中.
如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。
