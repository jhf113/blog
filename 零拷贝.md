# 零拷贝
**什么是零拷贝？**
零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区复制到另一个存储区，从而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。
零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率。而且，零拷贝技术减少了用户应用程序地址空间和操作系统内核地址空间之间因为上下文切换而带来的开销。
**操作系统中谁负责IO拷贝？**
DMA负责内核间的IO传输，CPU负责内核和应用间的IO传输。
**传统IO的执行流程？**
传统的IO流程，包括read和write的过程。read把数据从磁盘读取到内核缓冲区中，再拷贝到用户缓冲区；write先把数据写入到socket缓冲区，最后写入网卡设备。
流程如下：
* 用户应用进程调用read函数，向操作系统发起IO调用，上下文从用户态转为内核态（切换1）
* DMA控制器把数据从磁盘中，读取到内核缓冲区。
* CPU把内核缓冲区数据，拷贝到用户应用缓冲区，上下文从内核态转为用户态（切换2），read函数返回
* 用户应用进程通过write函数，发起IO调用，上下文从用户态转为内核态（切换3）
* CPU将用户缓冲区中的数据，拷贝到socket缓冲区
* DMA控制器把数据从socket缓冲区，拷贝到网卡设备，上下文从内核态切换回用户态（切换4），write函数返回

从流程可以看出，传统IO的读写流程，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（两次CPU拷贝以及两次的DMA拷贝)
**零拷贝的几种方法**
***方法一：mmap***
```
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```
我们可以使用mmap来代替read调用，这样可以减少一次拷贝次数。具体操作就是：应用程序调用mmap()，磁盘上的数据会通过DMA拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样久不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write()，操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态。最后，socket缓冲区再把数据发到网卡去。
但是mmap 隐藏着一个陷阱，当 mmap 一个文件时，如果这个文件被另一个进程所截获，那么 write 系统调用会因为访问非法地址被 SIGBUS 信号终止，SIGBUS 默认会杀死进程并产生一个 coredump，如果服务器被这样终止了，那损失就可能不小了。
解决方法：使用文件的租借锁，首先为文件申请一个租借锁，当其他进程想要截断这个文件时，内核会发送一个实时的 RT_SIGNAL_LEASE 信号，告诉当前进程有进程在试图破坏文件，这样 write 在被 SIGBUS 杀死之前，会被中断，返回已经写入的字节数，并设置 errno 为 success。
通常的做法是在 mmap 之前加锁，操作完之后解锁。
***方法二：sendfile***
```
#include<sys/sendfile.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```
sendfile是在Linux 2.1内核引入的系统调用，它是只发生在内核态的数据传输接口，没有用户态的参与，也就避免了用户态数据拷贝。它指定在in_fd和out_fd之间传输数据，其中，它规定in_fd指向的文件必须是可以mmap的，out_fd必须指向一个套接字，也就是说，它规定了数据只能从文件传输到套接字，反之则不行。sendfile不存在mmap时文件被截获的情况，它自带异常处理机制。
假设我们没有设置任何信号处理程序，sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收到RT_SIGNAL_LEASE的信号。
虽然sendfile仅剩一次内核的拷贝操作，但是我们可以借助DMA来辅助sendfile把这次拷贝也去掉。具体操作：在数据从内核缓冲区到socket缓冲区这一步奥坐上，并不是拷贝数据，而是拷贝缓冲区描述符，待完成后，DMA引擎直接将数据从内核缓冲区拷贝到协议引擎中去，避免了最后一次拷贝。
***方法三：splice***
```
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <fcntl.h>
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
```
为了解决sendfile只适用于文件到套接字这个限制，Linux在2.6.17版本又引入了splice系统调用，它可以用在两个文件描述符中移动数据。具体操作：splice调用在两个文件描述符之间移动数据，而不需要数据在内核空间和用户空间来回拷贝。他从fd_in拷贝len长度的数据到fd_out，但是有一方必须是管道设备，这也是目前splice的一些局限性。
**flags参数有以下几种取值：**
1. SPLICE_F_MOVE ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：如果内核不能从pipe移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据。Linux最初的实现有些问题，所以从2.6.21开始这个选项不起作用，后面的Linux版本应该会实现。
2. SPLICE_F_NONBLOCK ：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。
3. SPLICE_F_MORE： 后面的splice调用会有更多的数据。splice调用利用了Linux提出的管道缓冲区机制， 所以至少一个描述符要为管道。

以上几种零拷贝技术都是减少数据在用户空间和内核空间拷贝技术实现的，但是有些时候，数据必须在用户空间和内核空间之间拷贝。这时候，我们只能针对数据在用户空间和内核空间拷贝的时机上下功夫了。Linux通常利用写时复制(copy on write)来减少系统开销，这个技术又时常称作COW。
