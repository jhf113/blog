## 排序
三种快排及四种优化方式

来自 <https://blog.csdn.net/hacker00011000/article/details/52176100>

1. 冒泡排序
 + 从左到右两两比较，暴力解法。
 + 优化：当数组在整个遍历过程中，没有发生交换，说明数组已经有序的了，此时可以直接结束排序。


2. 选择排序

  + 设置一个最大值max；在数组中找到最大的设置为max，扔后面，再找，扔倒数第二位，以此类推。
3. 插入排序
  + 有序表和无序表，i为有序最后一个，j为无序第一个；（循环的时候，外层是无序表，内层是有序表）如果i对应元素比j对应的大，位置元素向前移，否则，对应的元素插入i所在的位置前一个。j继续向前走。
4. 希尔排序
  + 希尔排序对分组没有明确要求；但每次分组是上一次分组间隔的一半；换句话来说，编写代码时组数group每次循环要 group/2。
  + 外层是group的分组行为，中层和内层则是微调过的插入排序。
  + 思考： 既然希尔排序用到了插入排序，那我们为什么不一开始就用插入排序呢？
  + 分组之后跨度大，减少了不必要的比较
  + 下图是10000个元素用插入排序和希尔排序的对比，基数越大效果越明显。
5. 堆排序
  + 将数组调整成最大堆，根即为最大值，之后最大值和最后一个元素交换，以此往复。
  + 注释：若有n个元素，最后一个父节点为n/2-1;若已知父节点下标为i且他有子节点，则第一个子节点下标为2*i+1;
  + 堆排序：调整一个时间节点的时间复杂度为logN。
  + 思考：为什么初始化最大堆的时候不从上往下排？
6. 桶排序
7. 快速排序
代码实现：
```
 void quicksort(vector<int> &vec, int left, int right) {
    if (vec.size() == 0)return;
    if (left > right) {
        return;
    }
    int key = vec[left];//key纪录的是基准值
    int l = left;
    int r = right;//为了防止left，right被改变，然后赋值给l，r
    while (l!=r) {//循环遍历，先又后左找一个比基准值大的，一个比基准值小的
        while (vec[r] >= key && l < r) {//目的是在右边找到一个比基准值小的数
            r--;

        }
        while (vec[l] <= key && l < r) {//目的是在左边找一个比较基准值大的数
            l++;
        }
        if (l < r) {//找到目标数之后交换俩个数
            swap(vec[l], vec[r]);
        }

    }
    swap(vec[left], vec[l]);//基准值与当前l或者r（l与r在同一位置）位置的数交换
    quicksort(vec, left, l - 1);//快排左边
    quicksort(vec, l + 1, right);//快排右边
} 
```

 ![my-logo.png](https://wx3.sinaimg.cn/mw690/008peUCply1h1che84wmij30c50acaaj.jpg)

8. 归并排序
 + 先递归把数组中的元素拆开，分解到最后只剩下一个元素，之后合并并排序。
 
 + 编代码思路（递归）：既然选择递归，先写出口，该排序出口可设置为最右边的索引r<=1的时候；之后需要二分，即每次长度折半（mid=（r-l）/2)，分成两部分之后两部分分别递归。最后调用函数将数组合并排序。写一个被调用函数：
  -- 第一步申请一个r-l+1那么大的空间为了存储排好序的数组；
  -- 第二步写一个循环，将索引为【l-mid】之间的数和索引为【mid-r】之间的数组中元素比较；较大的存入之前申请的临时数组。
  -- 第三步，将【l-mid】或者【mid-r】未存入临时数组的数存入临时数组；
  -- 第四步，将临时数组中的数存入原数组。（在此之前要重新为index赋值，因为在之前index已经改变）
  -- 最后删除临时数组。
  
![my-logo.png](https://wx1.sinaimg.cn/mw690/008peUCply1h1che87vszj30nj0cgtb4.jpg)
