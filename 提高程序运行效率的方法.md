# 提高程序运行效率的方法
**● 尽量减少值传递，多用引用来传递参数**
```
bool Compare（string s1, string s2)
bool Compare(string *s1, string *s2)
bool Compare(string &s1, string &s2)
bool Compare(const string &s1, const string &s2)
```

第一个函数是值传递，则其在参数传递和函数返回时，需要调用string的构造函数和析构函数两次（共调用了四个函数），指针和引用都不会创建新的对象，所以不需要调用这个四次函数

**● ++i和i++引申出的效率问题**
```
_SingleList::Iterator& _SingleList::Iterator::operator++()//前加
{
    pNote = pNote->pNext;
    return *this;
}
_SingleList::Iterator _SingleList::Iterator::operator++(int)//后加
{
    Iterator tmp(*this);
    pNote = pNote->pNext;
    return tmp;
}
```

从后加的实现方式可以知道，对象利用自己创建一个临时对象（自己在函数调用的一个复制），然后改变自己的状态，并返回这个临时对象，而前加的实现方式时，直接改变自己的内部状态，并返回自己的引用。
从第一点的论述可以知道后加实现时会调用复制构造函数，在函数返回时还要调用析构函数，而由于前加实现方式直接改变对象的内部状态，并返回自己的引用，至始至终也没有创建新的对象，所以也就不会调用构造函数和析构函数。

**● 局部变量和静态变量**

局部变量比静态变量效率高，这是因为局部变量是存在于堆栈中的，对其空间的分配仅仅是修改一次esp寄存器的内容即可（即使定义一组局部变量也是修改一次）。而局部变量存在于堆栈中最大的好处是，函数能重复使用内存，当一个函数调用完毕时，退出程序堆栈，内存空间被回收，当新的函数被调用时，局部变量又可以重新使用相同的地址。当一块数据被反复读写，其数据会留在CPU的一级缓存（Cache）中，访问速度非常快。而静态变量却不存在于堆栈中。

**● 避免使用多继承**

这是因为在C++中每个对象都有一个this指针指向对象本身，而C++中类对成员变量的使用是通过this的地址加偏移量来计算的，而在多重继承的情况下，这个计算会变量更加复杂，从而降低程序的运行效率。而为了解决二义性，而使用虚基类的多重继承对效率的影响更为严重，因为其继承关系更加复杂和成员变量所属的父类关系更加复杂。

**● 避免过大循环**
```
代码1：
for(int i = 0; i < n; ++i)
{
    fun1();
    fun2();
}
```
```
代码2：
for(int i = 0; i < n; ++i)
{
    fun1();
}
for(int i = 0; i < n; ++i)
{
    fun2（);
}
```
注：这里的fun1（）和fun2()是没有关联的，即两段代码所产生的结果是一样的。

以代码的层面上来看，似乎是代码1的效率更高，因为毕竟代码1少了n次的自加运算和判断，毕竟自加运算和判断也是需要时间的。但是现实真的是这样吗？

这就要看fun1和fun2这两个函数的规模（或复杂性）了，如果这多个函数的代码语句很少，则代码1的运行效率高一些，但是若fun1和fun2的语句有很多，规模较大，则代码2的运行效率会比代码1显著高得多。可能你不明白这是为什么，要说是为什么这要由计算机的硬件说起。

由于CPU只能从内存在读取数据，而CPU的运算速度远远大于内存，所以为了提高程序的运行速度有效地利用CPU的能力，在内存与CPU之间有一个叫Cache的存储器，它的速度接近CPU。而Cache中的数据是从内存中加载而来的，这个过程需要访问内存，速度较慢。

这里先说说Cache的设计原理，就是时间局部性和空间局部性。时间局部性是指如果一个存储单元被访问，则可能该单元会很快被再次访问，这是因为程序存在着循环。空间局部性是指如果一个储存单元被访问，则该单元邻近的单元也可能很快被访问，这是因为程序中大部分指令是顺序存储、顺序执行的，数据也一般也是以向量、数组、树、表等形式簇聚在一起的。

看到这里你可能已经明白其中的原因了。没错，就是这样！如果fun1和fun2的代码量很大，例如都大于Cache的容量，则在代码1中，就不能充分利用Cache了（由时间局部性和空间局部性可知），因为每循环一次，都要把Cache中的内容踢出，重新从内存中加载另一个函数的代码指令和数据，而代码2则更很好地利用了Cache，利用两个循环语句，每个循环所用到的数据几乎都已加载到Cache中，每次循环都可从Cache中读写数据，访问内存较少，速度较快，理论上来说只需要完全踢出fun1的数据1次即可。

**● 将粒度小的函数声明为内联函数**

正如我们所知，调用函数是需要保护现场，为局部变量分配内存，函数结束后还要恢复现场等开销，而内联函数则是把它的代码直接写到调用函数处，所以不需要这些开销，但会使程序的源代码长度变大。
所以若是小粒度的函数，如下面的Max函数，由于不需要调用普通函数的开销，所以可以提高程序的效率。
```
int Max(int a, int b)
{
    return a>b?a:b;
}
```
**● 多用直接初始化**
```
ClassTest ct1；
ClassTest ct2(ct1);    //直接初始化
ClassTest ct3 = ct1;    //复制初始化
```
那么直接初始化与复制初始化又有什么不同呢？直接初始化是直接以一个对象来构造另一个对象，如用ct1来构造ct2，复制初始化是先构造一个对象，再把另一个对象值复制给这个对象，如先构造一个对象ct3，再把ct1中的成员变量的值复制给ct3，从这里，可以看出直接初始化的效率更高一点，而且使用直接初始化还是一个好处，就是对于不能进行复制操作的对象，如流对象，是不能使用赋值初始化的，只能进行直接初始化。
