# 页面置换算法
![Alt text](https://wx2.sinaimg.cn/mw2000/008sKdQply1h22g1zlv2bj30g809c77i.jpg)
## 1、NRU（最近未使用算法）
1. 系统为每一页设置了两个转胎位，当页面被访问（读或者写）设置为R位，当页面被写入（即修改）时设置为M位。
2. 当启动一个程序的时候，他的所有页面的两个位都被操作系统设置为0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面。

  当发生缺页中断时，操作系统会检查所有的页面并更具当前他们的R/M位，分为四类
	a. 第0类：没有被访问，没有被修改
	b. 第1类：没有被访问，已经被修改
	c. 第2类：已经被访问，没有被修改
	d. 第3类：已经被访问，已经被修改
3. 意义：在最近一个时钟滴答（20ms）中，淘汰一个没有被访问的已修改页面，要比淘汰一个被频繁使用的“干净页面”好。

## 2、FIFO（先进先出淘汰算法）

思想：最近刚访问的，将来访问的可能性比较大。

实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。
## 3、第二次页面置换算法

思想：检查最老页面的R位，如果R位是0，那么这个页面可以立刻被替换掉；如果是1，就将R位清0，并把该页面放到页面的尾端，修改装入时间，就和刚装入一样，然后继续搜索。

## 4、时钟页面置换算法
![Alt text](https://wx3.sinaimg.cn/mw2000/008sKdQply1h22g182r3uj30d108wdhq.jpg)
思想：当发生中断的时候，算法首先检查表针指向的页面，如果他的R位是0就淘汰该页面，并把新的页面插入到这个位置，然后指针前移一位，
如果R位是1就清楚R位并把表针前移一个位置。重复这个过程直到找到一个R位为0的页面为止。

## 5、LFU（最不经常访问淘汰算法）
思想：如果数据过去被访问多次，那么将来被访问的频率也更高。

实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。

开销：排序开销。 弊端：缓存颠簸。
![Alt text](https://wx4.sinaimg.cn/mw2000/008sKdQply1h22g1bk35nj30h1076jtw.jpg)
## 6、LRU（最近最少使用替换算法）
思想：如果数据最近被访问过，那么将来被访问的几率也更高。

实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。

需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。

优点：LRU算法对热点数据命中率是很高的。

缺陷：
1. 缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。
2. 缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。

## 7、工作集算法
工作集：一个进程当前使用的全部页面的集合称为工作集在任意时刻t,都存在一个集合，它包含所有最近K次内存访问所访问过的页面。这个集合w(k,t)就是工作集
1. 当发生缺页中断的时候，淘汰一个不在工作集的页面。
2.  一个进程从他开始执行到当前所实际使用的CPU时间总数通常称为当前运行时间。
	（Д）在过去的Д秒实际运行时间中他所访问过的页面的集合

## 8、LRU-K（LRU-2、LRU-3）
思想：最久未使用K次淘汰算法。

LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。
相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。

**实现：**
1. 数据第一次被访问，加入到访问历史列表；
2. 如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；
3. 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
4. 缓存数据队列中被再次访问后，重新排序；
5. 需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。

针对问题：
LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。

## 9、2Q
类似LRU-2。使用一个FIFO队列和一个LRU队列。
实现：
1. 新访问的数据插入到FIFO队列；
2. 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；
3. 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列尾部；
4. 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；
5. LRU队列淘汰末尾的数据。

针对问题：LRU的缓存污染

弊端：
当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。
