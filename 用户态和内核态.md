# 用户态和内核态
**（1） 什么使用户态和内核态**
● 内核态：处于内核的CPU可以访问任何数据，包括外围设备，比如网卡，硬盘等，处于内核的CPU可以从一个程序换到另一个程序，并且占用CPU不会发生抢占情况，一般处于特权级0的状态我们称之为内核态。
● 用户态：处于用户态的CPU只能受限的访问内存，并且不允许访问外围设备，用户下的CPU不允许独占，也就是说CPU能被其他程序获取。
为什么要有用户态和内核态？
这个主要是访问能力的限制考量，计算机中有一些比较危险的操作，比如设置时钟，内存清理，这些都是需要在内核态下完成的，如果随意进行这些操作，那你的系统将会崩溃。
**（2） 用户态和内核态如何进行切换的**
所有用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的操作，比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做得事，而这些数据却对用户来说十分重要，所以就涉及到两种模式下的转换，即用户态->内核态->用户态，而唯一能够做这些操作只有系统调用，而能执行系统调用的就只有操作系统。
一般用户态->内核态的转换我们都称之为trap进内核，也被称之为陷阱指令（trap instruction)
工作流程：
![Alt text](https://docimg4.docs.qq.com/image/9x9sf7YbIfanRiQc5oE5cw.png?w=770&h=595)
* 先用户程序会调用glibc库，glibc是一个标准库，同时也是一套核心库，库中定义了许多关键API
* glibc库知道针对不同体系结构调用系统调用的正确方法，他会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用
* 然后，glibc库调用软件中断指令（SWI)， 这个指令通过更新CPSR寄存器将模式改为超级用户模式，然后跳转到0x08
* 到目前为止，这个过程仍处于用户态，在执行SWI指令后，允许进程执行内核代码，MMU现在允许内核虚拟内存访问
* 从地址0x08开始，进程执行加载并跳转到中断处理程序，这个程序就是ARM中的vector_swi()
* 在vector_swi()处，从SWI指令中提取系统调用号SCNO，然后使用SCNO作为系统调用表sys_call_table的索引，调转到系统调用函数
* 执行系统调用完成后，将还原用户模式寄存器，然后在以用户模式运行。

**(3)用户态和内核态的区别**
* 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；

* 当程序运行在0级特权级上时，就可以称之为运行在内核态。

* 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

* 这两种状态的主要差别是

1. 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
2. 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。
